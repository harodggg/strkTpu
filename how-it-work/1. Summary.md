这份文档为您梳理了 **ZK-STARK (Zero-Knowledge Scalable Transparent Argument of Knowledge)** 的核心数学推理流程。

STARK 的核心在于将计算完整性问题转化为关于多项式的**低次性测试 (Low Degree Testing)**。本文档将按照 **计算算术化 (Arithmetization) $\rightarrow$ 多项式约束 (Constraints) $\rightarrow$ FRI 协议** 的逻辑路径进行推导。

---

# ZK-STARK 数学原理与推理 (Mathematical Derivation)

## 1. 预备知识与符号定义 (Preliminaries)

在 STARK 中，我们通常工作在一个有限域 $\mathbb{F}_p$ 上。

* **执行迹 (Execution Trace), $T$**: 一个 $W \times N$ 的矩阵，代表计算的每一步状态。
    * $N$: 计算的步数（通常为 $2$ 的幂）。
    * $W$: 寄存器的数量（宽度）。
* **乘法子群 (Subgroup)**: 设 $\omega$ 为 $\mathbb{F}_p$ 中的 $N$ 次单位根，即 $\omega^N = 1$。
    * **迹定义域 (Trace Domain)**: $D = \{ \omega^0, \omega^1, \dots, \omega^{N-1} \}$。
* **低次扩展 (LDE - Low Degree Extension)**:
    * 为了安全性，我们需要在一个更大的域 $D_{LDE}$ 上进行验证。
    * $D_{LDE}$ 的大小为 $N \times \rho$（$\rho$ 为放大因子，blowup factor）。

---

## 2. 算术化：AIR (Algebraic Intermediate Representation)

任何计算都可以表示为一组**代数中间表示 (AIR)**。AIR 由执行迹多项式和约束条件组成。

### 2.1 迹多项式插值
对于执行迹矩阵中的每一列 $w$（寄存器），我们在域 $D$ 上进行拉格朗日插值，得到一个度数小于 $N$ 的多项式 $P(x)$：

$$P(\omega^i) = T[i], \quad \forall i \in \{0, \dots, N-1\}$$

### 2.2 建立约束 (Constraints)
约束通常分为两类：

1.  **边界约束 (Boundary Constraints)**: 规定计算的输入和输出。
    * 例如：在第 $0$ 步，寄存器值为 $in$。
    * 公式：$P(\omega^0) - in = 0$。

2.  **状态转换约束 (Transition Constraints)**: 规定计算每一步必须遵循的逻辑（例如 Fibonacci 数列）。
    * 逻辑：$x_{i+2} - x_{i+1} - x_i = 0$。
    * 在多项式域中，$x$ 代表当前步，$x \cdot \omega$ 代表下一步。
    * 公式：$P(x \cdot \omega^2) - P(x \cdot \omega) - P(x) = 0$。

我们将所有约束统一表示为 $C(P(x), P(x \cdot \omega), \dots)$。如果计算是诚实的，则：

$$\forall x \in D_{\text{valid}}, \quad C(x) = 0$$

---

## 3. 转化为多项式除法问题 (Reduction to Polynomial Division)

为了证明 $C(x)$ 在特定域 $D$ 上为零，我们引入**归零多项式 (Vanishing Polynomial)** $Z_D(x)$。

### 3.1 归零多项式
对于域 $D = \{ \omega^0, \dots, \omega^{N-1} \}$，其归零多项式为：

$$Z_D(x) = \prod_{i=0}^{N-1} (x - \omega^i) = x^N - 1$$

### 3.2 商多项式 (Quotient Polynomial) $Q(x)$
如果证明者（Prover）是诚实的，那么约束多项式 $C(x)$ 在 $D$ 的所有点上都等于 0。这意味着 $C(x)$ 可以被 $Z_D(x)$ 整除。

我们构造商多项式 $Q(x)$：

$$Q(x) = \frac{C(P(x), P(x \cdot \omega), \dots)}{Z_D(x)}$$

**核心推理**：
* 如果证明是合法的，则 $Q(x)$ 是一个**低次多项式**（degree $\approx \text{deg}(C) - N$）。
* 如果证明是伪造的，$C(x)$ 不能被 $Z_D(x)$ 整除，算出来的 $Q(x)$ 将不是一个整多项式（或是一个度数极高的有理分式），在随机点验证时会失败。

---

## 4. 组合多项式 (Deep Composition Polynomial)

为了防止攻击者针对特定约束作弊，我们将所有约束（边界约束 $B(x)$ 和转换约束 $T(x)$）通过验证者提供的随机系数 $\alpha, \beta$ 线性组合成一个单一的**组合多项式 (Deep Composition Polynomial)** $H(x)$：

$$H(x) = \alpha \cdot \frac{B(x)}{Z_{B}(x)} + \beta \cdot \frac{T(x)}{Z_{T}(x)}$$

现在问题简化为：**证明者需要证明 $H(x)$ 是一个低次多项式。**

---

## 5. FRI 协议 (Fast Reed-Solomon Interactive Oracle Proof of Proximity)

这是 STARK 最精妙的部分。如何不传输整个巨大的多项式 $H(x)$ 而证明它的度数很低？FRI 使用了类似于 FFT 的**折叠 (Folding)** 思想。

### 5.1 多项式拆分
对于任意多项式 $f(x)$，我们可以将其拆分为偶数次项和奇数次项：

$$f(x) = f_E(x^2) + x \cdot f_O(x^2)$$

其中 $f_E$ 和 $f_O$ 的度数都是 $f(x)$ 的一半。

### 5.2 折叠 (Folding) 过程
验证者发送一个随机数 $\gamma$（Challenge）。证明者利用 $\gamma$ 将 $f(x)$ 降维为一个新的多项式 $f^*(y)$：

$$f^*(y) = f_E(y) + \gamma \cdot f_O(y), \quad \text{其中 } y = x^2$$

**推理逻辑**：
1.  如果 $f(x)$ 的度数是 $d$，那么 $f^*(y)$ 的度数是 $d/2$。
2.  定义域从 $D$ 映射到了 $D^2$（即每个元素平方），大小减半。
3.  重复此过程 $k$ 次，直到多项式变成一个常数（度数为 0）。

### 5.3 FRI 承诺阶段 (Commit Phase)
1.  **Layer 0**: Prover 计算 $H(x)$ 在 $D_{LDE}$ 上的所有值，构建 Merkle Tree，发送 Root。
2.  **Layer 1**: Verifier 发送 $\gamma_0$。Prover 计算折叠后的 $H_1(y)$，构建 Merkle Tree，发送 Root。
3.  ...
4.  **Layer k**: 得到常数 $C$，直接发送给 Verifier。

### 5.4 查询验证阶段 (Query Phase)
Verifier 随机选取 $D_{LDE}$ 中的一个点 $v$，要求 Prover 揭示 Merkle Path 来验证折叠的一致性：

验证公式为：
$$f^{(i)}(v) \stackrel{?}{=} f^{(i+1)}_E(v^2) + v \cdot f^{(i+1)}_O(v^2)$$
*(实际上是通过上一层的两个对称点 $v$ 和 $-v$ 来解出下一层 $v^2$ 的值)*

具体的一致性检查：
$$f^{(i+1)}(v^2) = \frac{f^{(i)}(v) + f^{(i)}(-v)}{2} + \gamma_i \cdot \frac{f^{(i)}(v) - f^{(i)}(-v)}{2v}$$

---

## 6. 总结 (Conclusion)

STARK 的完备性推理链条如下：

1.  **计算完整性** $\iff$ **Trace 满足 Constraints**。
2.  **Trace 满足 Constraints** $\iff$ **$C(x)$ 能被 $Z(x)$ 整除**。
3.  **$C(x)$ 能被 $Z(x)$ 整除** $\iff$ **$Q(x)$ 是低次多项式**。
4.  **$Q(x)$ 是低次多项式** $\iff$ **通过 FRI 协议的折叠验证**。

通过这种方式，STARK 实现了在 $O(\log^2 N)$ 的证明大小和验证时间内，验证 $O(N)$ 复杂度的计算，且不需要可信设置（Transparent）。